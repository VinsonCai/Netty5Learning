

ServerBootStrap 会有两个EventGroup。其中一个调用super.group(eventGroup);然后把child留给自己用。由此猜想，那个parent event group是负责读取消息的，而child eventGroup就负责处理读到的消息。

在unsafe（NioMessageUnsafe）开始读的时候，它会调用pipeline的fireChannelRead。然后这个pipeline会调用ChannelHandlerContext的fireChannelRead。ChannelHandlerContext会在链表中查找到一个合适的ChannelHandlerInvoker，然后调用 invoker.invokeChannelRead。
ChannelHandlerInvokerUtil调用invokeChannelReadNow。然后调用ChannelHandlerContext的handler()查找合适的handler去具体读。ctx.handler().channelRead（其中这里的handler就是返回SimpleChannelInboundHandler）.然后由SimpleChannelInboundHandler去调用抽象函数messageReceived。由子类去实现该方法。


1. 程序如何启动读数据线程？


在ServerBootStrap调用bind方法时，就会注册当通道可用的监听器。然后当通道启动时，就开始读。其实这里是有检查config().isAutoRead()的，因为默认是true，所以当通道active时就会自动读数据了。

2. 当一个channel读的数据不够时，我们是可以让它再去读多一些的。这个如果是在多条线程的话，是怎样处理的？


3. 


分类：
Bootstrap：是作为程序的加载入口
Unsafe：网络操作的IO实现类，像最终还是会出调用到NioByteUnsafe这样的类去做具体的工作。
ChannelPipeline：管理那些handler的类。像我们的把一个handler加入到列表时，就是加入到pipeline里面的。
HandlerContext：管理Handler的上下文。比如channel信息之类的。
ChannelHandlerInvoker：这是一个调用器，具体作用还不详。
ChannelHandler：就是一些处理信息的handler类。由一个责任链的方式把所有handler组合起来，每个Handler用不同的方式处理信息。
Future:异步操作的结果引用。这个跟java API里面的那个Future是差不多功能，但是在这里应该是有所加强的。
Promise：这个接口继承了Future，它是一个可以修改结果的Future，在系统里的使用挺多的。
EventLoopGroup：这些负责处理多线程的管理的。

