

ServerBootStrap 会有两个EventGroup。其中一个调用super.group(eventGroup);然后把child留给自己用。由此猜想，那个parent event group是负责读取消息的，而child eventGroup就负责处理读到的消息。

在unsafe（NioMessageUnsafe）开始读的时候，它会调用pipeline的fireChannelRead。然后这个pipeline会调用ChannelHandlerContext的fireChannelRead。ChannelHandlerContext会在链表中查找到一个合适的ChannelHandlerInvoker，然后调用 invoker.invokeChannelRead。
ChannelHandlerInvokerUtil调用invokeChannelReadNow。然后调用ChannelHandlerContext的handler()查找合适的handler去具体读。ctx.handler().channelRead（其中这里的handler就是返回SimpleChannelInboundHandler）.然后由SimpleChannelInboundHandler去调用抽象函数messageReceived。由子类去实现该方法。


1. 程序如何启动读数据线程？


在ServerBootStrap调用bind方法时，就会注册当通道可用的监听器。然后当通道启动时，就开始读。其实这里是有检查config().isAutoRead()的，因为默认是true，所以当通道active时就会自动读数据了。

2. 当一个channel读的数据不够时，我们是可以让它再去读多一些的。这个如果是在多条线程的话，是怎样处理的？
这个是由ByteToMessageDecoder控制的。就拿Factorial的Demo作为例子，它声明一个BigIntegerDecoder去继承ByteToMessageDecoder，然后其中在读取数据后，就会调用子类的decode方法把数据分为几段，然后对每一段调用HanlderContext的fireChannelRead方法，最终调用到FactorialClientHandler.messageReceived方法。
在ByteToMessageDecoder里面有一个cumulation的ByteBuf对象，它负责把每次读进来的数据缓冲。比如我们要求的数据长度是5，而第一次读进来只有4，那么它就会累积下来，然后读第二次，比如这次读了3，然后它就会把它们累加起来有8个Byte,然后继续调用子害的decode方法。这个时候就可以解码出一个数据了。
对于每一个channel是一条线程在处理，所以不会把这数据放在不同的线程处理。

3. 


分类：
Bootstrap：是作为程序的加载入口
Unsafe：网络操作的IO实现类，像最终还是会出调用到NioByteUnsafe这样的类去做具体的工作。
ChannelPipeline：管理那些handler的类。像我们的把一个handler加入到列表时，就是加入到pipeline里面的。
HandlerContext：管理Handler的上下文。比如channel信息之类的。
ChannelHandlerInvoker：这是一个调用器，具体作用还不详。
ChannelHandler：就是一些处理信息的handler类。由一个责任链的方式把所有handler组合起来，每个Handler用不同的方式处理信息。
Future:异步操作的结果引用。这个跟java API里面的那个Future是差不多功能，但是在这里应该是有所加强的。
Promise：这个接口继承了Future，它是一个可以修改结果的Future，在系统里的使用挺多的。
EventLoopGroup：这些负责处理多线程的管理的。



NioEventLoop对Selector有优化.

它在run方法里面，会循环去调用select函数，当有事件返回的时候，就调用processSelectedKeysOptimized或者processSelectedKeysPlain去处理。
这两个函数会调用processSelectedKey去读取数据。而这个函数就会调用NioUnsafe去做具体的读取工作。


MultithreadEventLoopGroup在创建线程的时候，是根据系统的处理器数量的2倍和系统配置的个数间取个最大值。在这个线程数组里面，每次调用next()的时候，就循环在这里获取一个引用。
在ServerBootstrap调用listen的时候，会异步调用到createChannel()方法。这个方法会调用上面提到的next()去获取一个EventLoop(其实这个就是一个SingleThreadEventLoop)，然后channelFactory().newChannel(eventLoop, childGroup);这里就是给每个channel分配一个eventloop和一个EventGroup。
在API里面，有EventLoop和EventLoopGroup，这两个东西在上面的分析里面体现出来了。

有一个GlobalEventExecutor，里面有一个函数public boolean inEventLoop(Thread thread)。在读取数据的时候，看到几次会判断当前线程是否在inEventLoop。感觉有点像UI线程的样子。
在GlobalEventExecutor里面，那个所谓的UI线程会循环去获取一个任务Runnable task = takeTask()去执行。
在takeTask()里面，它会先去延时任务列表里面取，
 1）如果没有延时任务（ScheduledFutureTask），就去taskQueue里面获取（这里的taskQueue是一个BlockingQueue，所以这里有可能阻塞到有任务来时）
 2）如果有延时任务，就获取延时的时间delayNanos（用纳秒表示），如果delayNanos>0然后就尝试在delayNanos的时间内从taskQueue里面获取任务。不然就直接在taskQueue里面poll().
   2.1)如果这两种情况都没有获取到任务，就从延时任务列表里面取一个任务放到taskQueue里面。然后把它取出来返回回去。这里如果还是为空，就继续前面的操作。
   
   
每次在判断是否executor.inEventLoop(),如果是就马上执行，不然就尝试safeExecuteOutbound（Runnable），该函数会调用 executor.execute(task)。

每个EventExecutor的inEventLoop()最终还是调用到GlobalEventExecutor的inEventLoop()。目前的发现是如此，但不敢肯定。
   
当NioServerSocketChannel.doReadMessages的时候，它会给每一个连接过来的客户端创建一个NioSocketChannel，然后给它分配一个EventLoopGroup。


在程序开始，我们会声明两个EventGroup，一个作为Boss，另一个作为Worker。每一个EventGroup是由很多的EventLoop组成。
在EcentLoop里面会循环地去调用NioUnsafe去读取数据。当读取到数据的时候，就会调用ChannelHandlerContext.fireChannelRead().
ChannelHandlerContext.fireChannelRead会调用DefaultChannelHandlerInvoker.invokeChannelRead，在这里会判断当前线程是不是inEventLoop里面。
然后就调用Handler去读数据了。


在Factorial的Demo里面，BigIntegerDecoder继承自ByteToMessageDecoder，这个ByteToMessageDecoder会把数据读进来，然后调用由子类实现的decode方法，把数据分割成几组数据，然后调用HandlerContext去处理。

在ServerBootStrap里面自己定义了一个ServerBootstrapAcceptor，它是整个ChannelHandler的第一个，
我们在声明ServerBootstrap对象的时候，给调用childHandler(new FactorialServerInitializer());这里并不是立马把它加到链表里面，而是在触发ServerBootstrapAcceptor.channelRead时才把它加到pipeLine里面。
同时在channelRead的时候，会调用child.unsafe().register(child.newPromise());去注册读事件，然后启动线程去循环读。

HandlerContext是一个很重要的类，在创建它是传进ChannelPipeline，Invoker，name和Handler，这些并不是什么特别Magic的东西，只是它需要持有这些引用以用于手面的操作。因为它要保存一个上下文数据，以供后面Handler使用。
在程序启动时，我们把一个个Hanlder加到Pipeline的后面。在ChannelPipeline里面维护的一个链表是由ChannelContext连起来的。
在NioUnsafe里面读到数据时，调用pipeline.fireChannelRead(byteBuf);这个函数会用HandlerContext的链表头调用head.fireChannelRead(msg)，然后在HandlerContext的fireChannelRead时，会找到它的下一个HandlerContext，通过它的invoker去调用invokeChannelRead。这个又调用InvokerUtil的invokeChannelReadNow。这里就会调用具体handler的handler.channelRead(ctx, msg);
如果这个Handler是一个ByteToMessage的子类，它在解码时就会把它解出来的东西又进行一次调用自己的HandlerContext.fireChannelRead(msg)这里又找它的下一个HandlerContext去处理。如此连成一个责任链处理信息。

以Factorial为例。它是有三个Handler：ZlibCodecFactory.newZlibDecoder， BigIntegerDecoder和FactorialClientHandler。
当数据从ChannelPipiline开始，会先启用zlibDecoder，然后ZlibDecoder会在它channelRead时调用BigIntegerDecoder的channelRead，然后又会调用到FactorialClientHandler的channelRead







