

ServerBootStrap 会有两个EventGroup。其中一个调用super.group(eventGroup);然后把child留给自己用。由此猜想，那个parent event group是负责读取消息的，而child eventGroup就负责处理读到的消息。

在unsafe（NioMessageUnsafe）开始读的时候，它会调用pipeline的fireChannelRead。然后这个pipeline会调用ChannelHandlerContext的fireChannelRead。ChannelHandlerContext会在链表中查找到一个合适的ChannelHandlerInvoker，然后调用 invoker.invokeChannelRead。
ChannelHandlerInvokerUtil调用invokeChannelReadNow。然后调用ChannelHandlerContext的handler()查找合适的handler去具体读。ctx.handler().channelRead（其中这里的handler就是返回SimpleChannelInboundHandler）.然后由SimpleChannelInboundHandler去调用抽象函数messageReceived。由子类去实现该方法。


1. 程序如何启动读数据线程？


在ServerBootStrap调用bind方法时，就会注册当通道可用的监听器。然后当通道启动时，就开始读。其实这里是有检查config().isAutoRead()的，因为默认是true，所以当通道active时就会自动读数据了。

2. 当一个channel读的数据不够时，我们是可以让它再去读多一些的。这个如果是在多条线程的话，是怎样处理的？


3. 


分类：
Bootstrap：是作为程序的加载入口
Unsafe：网络操作的IO实现类，像最终还是会出调用到NioByteUnsafe这样的类去做具体的工作。
ChannelPipeline：管理那些handler的类。像我们的把一个handler加入到列表时，就是加入到pipeline里面的。
HandlerContext：管理Handler的上下文。比如channel信息之类的。
ChannelHandlerInvoker：这是一个调用器，具体作用还不详。
ChannelHandler：就是一些处理信息的handler类。由一个责任链的方式把所有handler组合起来，每个Handler用不同的方式处理信息。
Future:异步操作的结果引用。这个跟java API里面的那个Future是差不多功能，但是在这里应该是有所加强的。
Promise：这个接口继承了Future，它是一个可以修改结果的Future，在系统里的使用挺多的。
EventLoopGroup：这些负责处理多线程的管理的。



NioEventLoop对Selector有优化.

它在run方法里面，会循环去调用select函数，当有事件返回的时候，就调用processSelectedKeysOptimized或者processSelectedKeysPlain去处理。
这两个函数会调用processSelectedKey去读取数据。而这个函数就会调用NioUnsafe去做具体的读取工作。


MultithreadEventLoopGroup在创建线程的时候，是根据系统的处理器数量的2倍和系统配置的个数间取个最大值。在这个线程数组里面，每次调用next()的时候，就循环在这里获取一个引用。
在ServerBootstrap调用listen的时候，会异步调用到createChannel()方法。这个方法会调用上面提到的next()去获取一个EventLoop(其实这个就是一个SingleThreadEventLoop)，然后channelFactory().newChannel(eventLoop, childGroup);这里就是给每个channel分配一个eventloop和一个EventGroup。
在API里面，有EventLoop和EventLoopGroup，这两个东西在上面的分析里面体现出来了。

有一个GlobalEventExecutor，里面有一个函数public boolean inEventLoop(Thread thread)。在读取数据的时候，看到几次会判断当前线程是否在inEventLoop。感觉有点像UI线程的样子。
在GlobalEventExecutor里面，那个所谓的UI线程会循环去获取一个任务Runnable task = takeTask()去执行。
在takeTask()里面，它会先去延时任务列表里面取，
 1）如果没有延时任务（ScheduledFutureTask），就去taskQueue里面获取（这里的taskQueue是一个BlockingQueue，所以这里有可能阻塞到有任务来时）
 2）如果有延时任务，就获取延时的时间delayNanos（用纳秒表示），如果delayNanos>0然后就尝试在delayNanos的时间内从taskQueue里面获取任务。不然就直接在taskQueue里面poll().
   2.1)如果这两种情况都没有获取到任务，就从延时任务列表里面取一个任务放到taskQueue里面。然后把它取出来返回回去。这里如果还是为空，就继续前面的操作。
   
   
每次在判断是否executor.inEventLoop(),如果是就马上执行，不然就尝试safeExecuteOutbound（Runnable），该函数会调用 executor.execute(task)。

每个EventExecutor的inEventLoop()最终还是调用到GlobalEventExecutor的inEventLoop()。目前的发现是如此，但不敢肯定。
   


VoidChannel是什么？





